# kaguchat_app/routes/admin_api_routes.py (新文件或修改 admin_routes.py)
from flask import Blueprint, jsonify, request, current_app
from flask_jwt_extended import jwt_required, get_jwt_identity # 假设你使用 JWT 进行 API 认证
from ..processors import get_table_processor
from ..exceptions import (
    ValidationError, PermissionDeniedError, NotFoundError,
    DuplicateEntryError, InvalidDataError, IntegrityError
)
from ..extensions import logger # 假设 TABLE_NAME_MAPPING 在 extensions.py
from functools import wraps

# 如果这是一个新文件，创建一个新的蓝图
# admin_bp = Blueprint('admin_bp', __name__, url_prefix="/api/admin")
# 如果是修改 admin_routes.py，你需要调整 url_prefix，或者添加新的路由到 admin_bp

# 为了演示，我们假设在现有的 admin_bp (kaguchat_app/routes/admin_routes.py) 中添加 API 路由
# 你需要确保这个 admin_bp 的 url_prefix 是 /api/admin 或者你前端 API 调用的基础路径
# 如果 admin_bp 的 url_prefix 已经是 /admin (用于模板)，那么你需要一个新的蓝图给 /api/admin

# --- 假设我们创建一个新的蓝图专门用于 API ---
admin_bp = Blueprint(
    'admin_bp',
    __name__,
    url_prefix='/api/admin' # 与前端 adminApi.js 的 API_BASE_URL 匹配
)

# API 的权限检查 (如果使用 JWT)
def api_admin_required(fn):
    @wraps(fn)
    @jwt_required()
    def wrapper(*args, **kwargs):
        # current_user_id = get_jwt_identity()
        # TODO: 实现基于 user_id 的管理员角色检查逻辑
        # if not user_is_admin(current_user_id):
        #     return jsonify(msg="Admin access required"), 403
        return fn(*args, **kwargs)
    return wrapper

@admin_bp.route('/config/tables', methods=['GET'])
@api_admin_required # 或者你现有的 admin_required (如果它适配 JWT)
def get_admin_tables_config():
    """
    对应前端 getAdminTables()
    返回可管理的表名列表及其显示名。
    """
    # TABLE_NAME_MAPPING_FOR_ADMIN 来自 app.config 或 extensions.py
    # config.py 中的 TABLE_NAME_MAPPING_FOR_ADMIN 是 { "users": "Users", ... }
    # 前端期望的是 [{key: "users", displayName: "Users"}, ...]

    # 从 app.config 获取映射
    table_mapping = current_app.config.get('TABLE_NAME_MAPPING_FOR_ADMIN', {})
    tables_for_frontend = [
        {"key": key, "displayName": display_name}
        for key, display_name in table_mapping.items()
    ]
    return jsonify(tables=tables_for_frontend), 200


@admin_bp.route('/table/<table_name_display>/schema', methods=['GET'])
@api_admin_required
def get_table_schema_api(table_name_display):
    """
    对应前端 getTableSchema()
    返回表的结构信息，用于动态生成表单和表格列。
    """
    processor = get_table_processor(table_name_display)
    if not processor:
        return jsonify(msg=f"Table '{table_name_display}' not found or not managed."), 404

    try:
        # 你需要扩展你的 BaseTableProcessor 或具体 Processor 来提供更详细的 schema 信息
        # 例如，字段类型、是否必需、标签、默认值等，以便前端能正确渲染表单
        # 这里是一个简化的示例，你需要充实它
        all_columns_details = []
        db_cols = processor.columns # 原始数据库列名
        form_add_fields = processor.get_form_fields_add()
        # 理想情况下，get_form_fields_edit 应该返回字段名列表，而不是 HTML
        # 或者，你需要一个新的方法来获取编辑字段的定义

        for col_name in db_cols:
            # 这里需要更智能的逻辑来确定类型、标签等
            # 例如，从数据库元数据或预定义配置中获取
            field_info = {
                "name": col_name,
                "label": col_name.replace('_', ' ').title(), # 简单的标签生成
                "type": "text", # 需要根据实际列类型推断 (varchar, int, bool, date, etc.)
                "required": False, # 需要根据数据库约束或业务逻辑确定
                "editable": col_name not in [processor.primary_key] + processor._datetime_fields, # 简单示例
                "isPrimaryKey": col_name == processor.primary_key,
                "autoGenerated": col_name in processor._datetime_fields
                # "placeholder": f"Enter {col_name.replace('_', ' ').title()}",
                # "options": [] # 如果是 select 类型
                # "defaultValue": ...
            }
            # 简单的类型推断示例 (需要更完善)
            if "id" in col_name and col_name != processor.primary_key:
                field_info["type"] = "number" # 可能是外键
            elif col_name == "password":
                field_info["type"] = "password"
            elif "email" in col_name:
                field_info["type"] = "email"
            elif "phone" in col_name:
                 field_info["type"] = "tel"
            elif "url" in col_name:
                 field_info["type"] = "url"
            elif col_name in ['content', 'description', 'bio', 'remark']:
                 field_info["type"] = "textarea"
            elif col_name in ['created_at', 'sent_at', 'join_at', 'updated_at']:
                 field_info["type"] = "datetime" # 或 "date"
                 field_info["readOnly"] = True # 通常自动管理的字段是只读的
            elif col_name in ['status', 'role', 'message_type', 'is_admin', 'active']: # 假设这些可能是数字或布尔
                 # 你可能需要更具体的类型，比如 'boolean' 或 'select' (带选项)
                 # 如果是 boolean，前端 AdminTableManagerPage 需要相应处理
                 # 假设 status/role/message_type 在数据库中是 tinyint，前端可能想用数字输入或下拉选择
                 field_info["type"] = "number" # 或 "select" 如果有固定选项
            all_columns_details.append(field_info)

        schema_info = {
            "table_name_display": processor.table_name_display,
            "primary_key": processor.primary_key,
            "columns_for_display": processor.get_display_columns(), # 用于表格显示的列
            "form_fields_add": form_add_fields, # 用于添加表单的字段名列表
            "editable_fields": [col for col in processor.columns if col != processor.primary_key and col not in processor._datetime_fields], # 可编辑字段列表 (简单示例)
            "all_columns": all_columns_details, # 包含每个列详细信息的列表
            # "modal_width": 720 # 可选，如果想从后端控制模态框宽度
        }
        return jsonify(schema_info), 200
    except Exception as e:
        logger.error(f"Error fetching schema for table '{table_name_display}': {str(e)}", exc_info=True)
        return jsonify(msg=f"Error fetching schema: {str(e)}"), 500


@admin_bp.route('/table/<table_name_display>/data', methods=['GET'])
@api_admin_required
def get_table_data_api(table_name_display):
    """
    对应前端 getTableData()
    获取指定表的所有数据记录。
    """
    processor = get_table_processor(table_name_display)
    if not processor:
        return jsonify(msg=f"Table '{table_name_display}' not found or not managed."), 404
    try:
        data = processor.get_all_data() # 应该返回字典列表
        return jsonify(data=data, primary_key=processor.primary_key), 200
    except Exception as e:
        logger.error(f"Error fetching data for table '{table_name_display}': {str(e)}", exc_info=True)
        return jsonify(msg=f"Error fetching data: {str(e)}"), 500

@admin_bp.route('/table/<table_name_display>/data', methods=['POST'])
@api_admin_required
def add_table_record_api(table_name_display):
    """
    对应前端 addTableRecord()
    添加一条新记录到指定表。
    """
    processor = get_table_processor(table_name_display)
    if not processor:
        return jsonify(msg=f"Table '{table_name_display}' not found or not managed."), 404

    json_data = request.get_json()
    if not json_data:
        return jsonify(msg="Missing JSON data in request body"), 400

    try:
        # 注意：前端传来的可能是原始值，processor.process_add 需要处理它们
        # process_add 内部应该调用 validate_add 和 prepare_data_for_add
        # 假设 process_add 现在接收字典而不是 request.form

        # _extract_values_from_form 在 BaseProcessor 中是从 form_data (MultiDict) 提取的
        # 对于 API，我们直接用 json_data，但需要确保字段名一致
        # 并且 BaseProcessor 的 _extract_values_from_form 将空字符串转为 None

        # 模拟 _extract_values_from_form 的行为，但针对 JSON
        raw_values = {
            key: (value.strip() if isinstance(value, str) else value) if value not in ['', None] else None
            for key, value in json_data.items()
        }

        # 重新定义 process_add 以接受字典 (或者修改 BaseTableProcessor)
        # 假设 processor.process_add_from_dict(raw_values)
        # 或者，我们需要调整 processor.process_add 的参数来处理 dict
        # 为了简单，我们直接调用验证和准备方法
        processor.validate_add(raw_values, json_data) # 第二个参数 form_data 在 API 场景下可以是 json_data
        prepared_values = processor.prepare_data_for_add(raw_values, json_data)

        new_record_id = processor.table_service.add_record(processor.table_name_actual, prepared_values)
        if new_record_id is None: # add_record 可能返回 None 或 0 表示失败
            raise Exception("Failed to add record to database.")

        # 获取新添加的记录以返回给前端
        new_record = processor.get_record_by_id(new_record_id)
        return jsonify(msg="Record added successfully", record=new_record), 201
    except (ValidationError, DuplicateEntryError, InvalidDataError, IntegrityError) as e:
        logger.warning(f"Validation/DB error adding record to '{table_name_display}': {str(e)}")
        return jsonify(msg=str(e), field_name=getattr(e, 'field_name', None)), 400 # Bad Request
    except Exception as e:
        logger.error(f"Unexpected error adding record to '{table_name_display}': {str(e)}", exc_info=True)
        return jsonify(msg=f"Error adding record: {str(e)}"), 500

@admin_bp.route('/table/<table_name_display>/data/<record_id>', methods=['PUT'])
@api_admin_required
def update_table_record_api(table_name_display, record_id):
    """
    对应前端 updateTableRecord()
    更新指定表中的特定记录。
    """
    processor = get_table_processor(table_name_display)
    if not processor:
        return jsonify(msg=f"Table '{table_name_display}' not found or not managed."), 404

    json_data = request.get_json()
    if not json_data:
        return jsonify(msg="Missing JSON data in request body"), 400

    try:
        current_record_dict = processor.get_record_by_id(record_id)
        if not current_record_dict: # get_record_by_id 会在找不到时抛 NotFoundError，这里多一层保险
            raise NotFoundError(f"Record with ID {record_id} not found.")

        # 模拟 _extract_values_from_form
        raw_values_from_payload = {
            key: (value.strip() if isinstance(value, str) else value) if value not in ['', None] else None
            for key, value in json_data.items()
        }

        # 验证和准备数据
        # 注意：validate_edit 和 prepare_data_for_edit 在 BaseProcessor 中的签名
        # 是 (self, record_id, raw_values_from_form, current_record_dict, form_data)
        # form_data 在 API 场景可以是原始的 json_data
        processor.validate_edit(record_id, raw_values_from_payload, current_record_dict, json_data)
        prepared_values_for_update = processor.prepare_data_for_edit(record_id, raw_values_from_payload, current_record_dict, json_data)

        if prepared_values_for_update: # 只有当有值需要更新时才执行
            rows_affected = processor.table_service.update_record(
                processor.table_name_actual,
                processor.primary_key,
                record_id,
                prepared_values_for_update
            )
            # 根据 rows_affected 判断是否成功，或者直接获取更新后的记录

        updated_record = processor.get_record_by_id(record_id) # 获取更新后的记录
        return jsonify(msg="Record updated successfully", record=updated_record), 200
    except NotFoundError as e:
        return jsonify(msg=str(e)), 404
    except (ValidationError, DuplicateEntryError, InvalidDataError, IntegrityError) as e:
        logger.warning(f"Validation/DB error updating record '{record_id}' in '{table_name_display}': {str(e)}")
        return jsonify(msg=str(e), field_name=getattr(e, 'field_name', None)), 400
    except Exception as e:
        logger.error(f"Unexpected error updating record '{record_id}' in '{table_name_display}': {str(e)}", exc_info=True)
        return jsonify(msg=f"Error updating record: {str(e)}"), 500

@admin_bp.route('/table/<table_name_display>/data/<record_id>', methods=['DELETE'])
@api_admin_required
def delete_table_record_api(table_name_display, record_id):
    """
    对应前端 deleteTableRecord()
    删除指定表中的特定记录。
    """
    processor = get_table_processor(table_name_display)
    if not processor:
        return jsonify(msg=f"Table '{table_name_display}' not found or not managed."), 404
    try:
        # 确保记录存在并执行验证 (validate_delete 可能需要 current_record)
        current_record = processor.get_record_by_id(record_id)
        processor.validate_delete(record_id, current_record) # 假设 validate_delete 不需要 form_data

        rows_affected = processor.table_service.delete_record(
            processor.table_name_actual,
            processor.primary_key,
            record_id
        )
        if rows_affected == 0 or rows_affected is None: # delete_record 可能返回影响的行数或None
             # 如果 get_record_by_id 已经抛出 NotFoundError，这里可能不会执行
             # 但如果删除操作本身因为某些原因（如并发删除）没找到记录，可以这样处理
            raise NotFoundError(f"Record with ID {record_id} not found or already deleted.")

        return jsonify(msg="Record deleted successfully"), 200 # 或 204 No Content
    except NotFoundError as e:
        return jsonify(msg=str(e)), 404
    except PermissionDeniedError as e: # 如果 validate_delete 抛出
         return jsonify(msg=str(e)), 403
    except IntegrityError as e: # 例如，如果记录被外键约束保护不能删除
        logger.warning(f"Integrity error deleting record '{record_id}' from '{table_name_display}': {str(e)}")
        return jsonify(msg=f"Cannot delete record due to database integrity constraints: {str(e)}"), 409 # Conflict
    except Exception as e:
        logger.error(f"Unexpected error deleting record '{record_id}' from '{table_name_display}': {str(e)}", exc_info=True)
        return jsonify(msg=f"Error deleting record: {str(e)}"), 500

# 你还需要在你的主应用 (__init__.py) 中注册这个新的蓝图
# from .routes.admin_api_routes import admin_bp
# app.register_blueprint(admin_bp)